#
# Script that
#  1) reads yaml config gile
#  2) fetches CED elements defined in config file
#  3) fetches Mya data for CED elements as specified in config file
#  4) fetches global Mya data
#  5) - TBD for each interval specified in config file that passes filters:
#  5)   - TBD Output nodes in HBG file format
#  6)   - TBD Build edges and output in HBF format

from node import *
from ced import *
from mya import Sampler
import argparse
import os
import sys


# Suppress the warnings we know will be generated by having to
# bypass SSL verification because of the annoying JLAB MITM
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# the list of nodes that will be used to output graph data
node_list = []

# the global data that will be used for filtering
global_data = []

# CED Type hierarchy tree for using to match specific retrieved types
# to the possibly more generic (i.e. parent) type names encountered in the config dictionary.
# For example to determine that an element whose type is QB is also a "Quad" and a "Magnet"
tree = TypeTree()


# Define the program's command line arguments and build a parser to process them
def make_cli_parser():
    parser = argparse.ArgumentParser(description='Command Line Options')
    parser.add_argument("-c", type=str, dest='config_file', default="config.yaml",
                        help="Name of a yaml formatted config file")
    parser.add_argument("-d", type=str, dest='output_dir', default=".",
                        help="Directory where generated graph file hierarchy will be written")
    parser.add_argument("-o", action='store_true', help="Overwrite existing files")
    parser.add_argument("-tree", type=str, dest='tree_file',
                        help="Name of a json file containing ced type hierarchy")
    parser.add_argument("--read-nodes", type=str, dest='read_nodes_file',
                        help = "Name of a json file containing node data")
    parser.add_argument("--save-nodes", type=str, dest='save_nodes_file',
                        help = "Name of a file for saving json-formatted node data")
    return parser


try:
    # Access the command line arguments
    args = make_cli_parser().parse_args()

    # Before doing any time-consuming work, verify the output dir is writable
    if not os.access(args.output_dir, os.X_OK | os.W_OK):
        sys.exit('Unable to write to output directory ' + args.output_dir)


    # Read configuration yaml file
    stream = open(args.config_file, 'r')
    config = yaml.load(stream, Loader=yaml.CLoader)

    # See if the type tree data should be read from file rather than retrieved from CED
    if args.tree_file:
        with open(args.tree_file, 'r') as treefile:
            data = treefile.read()
        tree = TypeTree()
        tree.tree = json.loads(data)  # prepopulate the data so no need to lazy-load later

    # See if the user wants to load nodes data from file rather than hitting archiver
    if args.read_nodes_file:
        # Read nodes data from specified file
        node_list = List.from_json(args.read_nodes_file,'tests/type-tree.json',args.config_file)
    else:
        # Use CED and MYA to build nodes list

        # Begin by fetching the desired CED elements
        inventory = Inventory(config['ced']['zone'], config['ced']['types'], config['ced']['properties'])
        elements = inventory.elements()

        # It's important to preserve the order of the elements in the nodeList.
        # We are going to assign each node a node_id property that corresponds to its
        # order in the list beginning at 0.
        node_id = 0
        for element in elements:
            node = List.make_node(element, tree, config)

            # If no node was created, it means that there was not type match.  This could happen if
            # the CED query was something broad like "BeamElem", but the config file only indicates the
            # desired EPICS fields for specific sub-types (Magnet, BPM, etc.)
            if node:
                # Assign id values based on order of encounter
                node.node_id = node_id
                node_list.append(node)
                node_id += 1

    # For debugging
    for item in node_list:
        print(item)

    # Save the node list to a file for later use?
    if args.save_nodes_file:
        # Save the node_list to a file
        f = open(args.save_nodes_file, "w")
        json.dump(node_list, f, cls=ListEncoder)
        f.close()

    # stop here for now
    exit(0)

    # Retrieve the global PV list
    global_data = Sampler(
        config['mya']['begin'],
        config['mya']['end'],
        config['mya']['interval'],
        config['mya']['global']
    ).data()

    # Now filter the nodeList based on global values
    # For the moment we're using hard-coded conditions, but eventually the goal is to
    # do some sort of eval on the filters specified in the yaml config file
    i = 0
    valid_indexes = []
    for data in global_data:
        for value in data['values']:
            current_filter_value = mya.get_pv_value(data['values'], 'IBC0R08CRCUR1')
            if current_filter_value and  float(current_filter_value) > 0:
                print(data['date']+' '+current_filter_value)
                # TODO accumulate the corresponding node data
        i += 1
   
    print(node_list)

except json.JSONDecodeError:
    print("Oops!  Invalid JSON response. Check request parameters and try again.")
    exit(1)
except RuntimeError as err:
    print("Exception: ", err)
    exit(1)



