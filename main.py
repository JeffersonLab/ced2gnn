# Test requests package

import yaml
from ced import *
from mya import Sampler

# Suppress the warnings we know will be generated by having to
# bypass SSL verification because of the annoying JLAB MITM
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# Store the list of nodes that will be used to output graph data
nodeList = []

try:
    # Read configuration yaml file
    stream = open("config.yaml", 'r')
    configDictionary = yaml.load(stream, Loader=yaml.CLoader)

    # Obtain a list containing the desired CED elements
    inventory = Inventory(configDictionary['ced']['zone'], configDictionary['ced']['types'])
    elements = inventory.elements()

    # We need to fetch the CED type hierarchy for use to match specific retrieved types
    # to the possibly more generic (i.e. parent) type names encountered in the config dictionary.
    # For example to determine that an element whose type is QB is also a "Quad" and a "Magnet"
    tree = TypeTree()

    # Now use the config dictionary and element list to create a list of
    # ced.Node objects, each initialized with a data sampler object that they
    # will later use to retrieve archiver data.

    # Note that it's important to preserve the order of the elements in the nodeList.
    for element in elements:
        # Create a new sampler instance for each node we're about to create
        sampler = Sampler(
            configDictionary['mya']['begin'],
            configDictionary['mya']['end'],
            configDictionary['mya']['interval'],
        )
        # We will match the type of the element to the types specified in the
        # config file to determine whether to instantiate as ReadBack or SetPoint nodes
        # TODO account for overlapping config settings
        for type_name, fields in configDictionary['nodes']['setpoints'].items():
            if tree.is_a(type_name, element['type']):
                nodeList.append(SetPointNode(element,fields, sampler))
        for type_name, fields in configDictionary['nodes']['readbacks'].items():
            if tree.is_a(type_name, element['type']):
                nodeList.append(ReadBackNode(element,fields, sampler))

    # Print some data from each node
    for node in  nodeList:
        print(node.pv_data_at('2021-10-01T00:00:00'))

    exit(0)

except json.JSONDecodeError:
    print("Oops!  Invalid JSON response. Check request parameters and try again.")
    exit(1)
except RuntimeError as err:
    print("Excaption: ", err)
    exit(1)
