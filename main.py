#
# Script that
#  1) reads yaml config gile
#  2) fetches CED elements defined in config file
#  3) fetches Mya data for CED elements as specified in config file
#  4) fetches global Mya data
#  5) - TBD for each interval specified in config file that passes filters:
#  5)   - TBD Output nodes in HBG file format
#  6)   - TBD Build edges and output in HBF format

import yaml
from ced import *
from mya import Sampler

# Suppress the warnings we know will be generated by having to
# bypass SSL verification because of the annoying JLAB MITM
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# Store the list of nodes that will be used to output graph data
node_list = []

# Store the global data that will be used for filtering
global_data = []

try:
    # Read configuration yaml file
    stream = open("config.yaml", 'r')
    config = yaml.load(stream, Loader=yaml.CLoader)

    # Obtain a list containing the desired CED elements
    inventory = Inventory(config['ced']['zone'], config['ced']['types'])
    elements = inventory.elements()

    # We need to fetch the CED type hierarchy for use to match specific retrieved types
    # to the possibly more generic (i.e. parent) type names encountered in the config dictionary.
    # For example to determine that an element whose type is QB is also a "Quad" and a "Magnet"
    tree = TypeTree()

    # Retrieve and store the global PV list
    global_data = Sampler(
            config['mya']['begin'],
            config['mya']['end'],
            config['mya']['interval'],
            config['mya']['global']
        ).data()

    # Now use the config dictionary and element list to create a list of
    # ced.Node objects, each initialized with a data sampler object that they
    # will later use to retrieve archiver data.

    # Note that it's important to preserve the order of the elements in the nodeList.
    for element in elements:
        # Create a new sampler instance for each node we're about to create
        sampler = Sampler(
            config['mya']['begin'],
            config['mya']['end'],
            config['mya']['interval'],
        )
        # We will match the type of the element to the types specified in the
        # config file to determine whether to instantiate as ReadBack or SetPoint nodes
        # TODO account for overlapping config settings
        for type_name, fields in config['nodes']['setpoints'].items():
            if tree.is_a(type_name, element['type']):
                node_list.append(SetPointNode(element, fields, sampler))
        for type_name, fields in config['nodes']['readbacks'].items():
            if tree.is_a(type_name, element['type']):
                node_list.append(ReadBackNode(element, fields, sampler))

    # Print some data from each node
    for node in  node_list:
        print(node.pv_data_at_datetime('2021-10-01T00:00:00'))

    exit(0)

except json.JSONDecodeError:
    print("Oops!  Invalid JSON response. Check request parameters and try again.")
    exit(1)
except RuntimeError as err:
    print("Excaption: ", err)
    exit(1)
